KNN
===========================================
过拟合和欠拟合
  过拟合
    产生原因：一般是由于K值选择过小导致的。
  欠拟合：
    产生原因：一般是由于K值选择过大导致的。
  解决方案：
    选择一个合适的K值，一般根据根据各个类别的数据量来选择
	  如果每个类别的数据量大概在100以内，那么K一般等于5~10
	  如果每个类别的数量大概在100~1000左右，那么K一般等于10~50
	  如果每个类别的数量超过1000的话，那么K一般选择50~100
	NOTE: 具体最优的K值可以通过网格交叉验证给定

伪代码：
  -1. 最简单的伪代码写法
	def fit(train, k):
	  self.train = train
	  self.k = k
  
    def predict(test):
	  # NOTE: 假定test中只有一个样本
	  # 1. 从train集合中获取和test最相似的K个邻居样本数据
	  # TODO: 自己去完善一下fetch_k_neighbors这个方法应该做了哪些操作，也就是这个方法对应的伪代码是什么.... ----> 如果这个做完后，考虑一下使用Python来实现KNN算法
	  neighbors = fetch_k_neighbors(self.train, test, self.k)
	  
	  # 2. 根据获取得到的结果得到最优可能的类别
	  # a. 统计一下各个类别出现的数目
	  result = {}
	  for record in neighbors:
	    # i. 获取当前样本的目标属性y值
		target_y = record.y
		# ii. 如果该值不在result列表中，那么进行添加，如果在，进行更新
		if target_y not in result:
		  count = 0
		else:
		  count = result.get(target_y)
		count += 1
		result[target_y] = count
	  # b. 从字典数据中获取出现次数最多的那个类别
	  max_count = -1
	  result_type = None
	  for k, v in result.items():
	    if v > max_count:
		  max_count = v
		  result_type = k
	  
	  return result_type
	  
	  
================================================
如果认为房产为特征属性x1, 婚姻情况为特征属性x2, 年收入为特征属性x3, 无法偿还债务为目标属性y；
x1={1,0} -> 1: 有房产，0：无房产
x2={2,1,0} -> 2: 结婚, 1：离婚, 0: 单身
x3={连续值}
y={1,0} -> 1:有还款能力，0表示没有还款能力

def predict(x=[x1,x2,x3]):
  if x3 >= 97.5:
    return 1
  else:
    if x2 == 1:
	  return 1
	elif x2 == 0:
	  if x1 == 1:
	    return 0
	  elif x1 == 2:
	    return 1
	  elif x1 == 0:
	    return 0
	  else:
	    return -1
	else:
	  return -1
	  
	  